package com.quantlab.backend.domain;

import com.quantlab.backend.entity.Candle;
import com.quantlab.backend.entity.Instrument;
import com.quantlab.backend.entity.Side;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Objects;

/**
 * Domain model representing a trading signal generated by a strategy.
 * <p>
 * This is a lightweight domain object, NOT a JPA entity.
 * It represents a signal to trade, not an executed trade.
 * Signals can be persisted to the database via TradeSignal entity.
 * <p>
 * A signal contains:
 * - The instrument to trade
 * - The date the signal was generated
 * - The side (BUY or SELL)
 * - Entry price, stop loss, and target price
 * - Quantity (number of shares/contracts)
 */
public class TradeSignal {

    private final Instrument instrument;
    private final LocalDate signalDate;
    private final Side side;
    private final BigDecimal entryPrice;
    private final BigDecimal stopLoss;
    private final BigDecimal targetPrice;
    private final int quantity;

    /**
     * Creates a new trade signal.
     *
     * @param instrument The instrument to trade
     * @param signalDate The date the signal was generated
     * @param side       BUY or SELL
     * @param entryPrice Recommended entry price
     * @param stopLoss   Stop loss price (nullable for strategies without SL)
     * @param targetPrice Target price (nullable for strategies without target)
     * @param quantity   Number of shares/contracts
     */
    public TradeSignal(Instrument instrument, LocalDate signalDate, Side side,
                       BigDecimal entryPrice, BigDecimal stopLoss,
                       BigDecimal targetPrice, int quantity) {
        if (instrument == null) {
            throw new IllegalArgumentException("Instrument cannot be null");
        }
        if (signalDate == null) {
            throw new IllegalArgumentException("Signal date cannot be null");
        }
        if (side == null) {
            throw new IllegalArgumentException("Side cannot be null");
        }
        if (entryPrice == null || entryPrice.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Entry price must be positive");
        }
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
        if (stopLoss != null && stopLoss.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Stop loss must be positive if provided");
        }
        if (targetPrice != null && targetPrice.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Target price must be positive if provided");
        }

        this.instrument = instrument;
        this.signalDate = signalDate;
        this.side = side;
        this.entryPrice = entryPrice;
        this.stopLoss = stopLoss;
        this.targetPrice = targetPrice;
        this.quantity = quantity;
    }

    /**
     * Creates a trade signal from a candle.
     * Convenience method for strategies that signal at candle close.
     */
    public static TradeSignal fromCandle(Candle candle, Side side, BigDecimal entryPrice,
                                          BigDecimal stopLoss, BigDecimal targetPrice, int quantity) {
        return new TradeSignal(
            candle.getInstrument(),
            candle.getTradeDate(),
            side,
            entryPrice,
            stopLoss,
            targetPrice,
            quantity
        );
    }

    /**
     * Creates a simple BUY signal without stop loss or target.
     */
    public static TradeSignal simpleBuy(Instrument instrument, LocalDate signalDate,
                                         BigDecimal entryPrice, int quantity) {
        return new TradeSignal(instrument, signalDate, Side.BUY, entryPrice, null, null, quantity);
    }

    /**
     * Creates a BUY signal with stop loss (no target).
     */
    public static TradeSignal buyWithStop(Instrument instrument, LocalDate signalDate,
                                           BigDecimal entryPrice, BigDecimal stopLoss, int quantity) {
        return new TradeSignal(instrument, signalDate, Side.BUY, entryPrice, stopLoss, null, quantity);
    }

    /**
     * Calculates the risk per unit (entry - stop loss for long positions).
     * Returns zero if stop loss is not set.
     */
    public BigDecimal getRiskPerUnit() {
        if (stopLoss == null) {
            return BigDecimal.ZERO;
        }
        return side == Side.BUY
            ? entryPrice.subtract(stopLoss)
            : stopLoss.subtract(entryPrice);
    }

    /**
     * Calculates the potential reward per unit (target - entry for long positions).
     * Returns zero if target is not set.
     */
    public BigDecimal getRewardPerUnit() {
        if (targetPrice == null) {
            return BigDecimal.ZERO;
        }
        return side == Side.BUY
            ? targetPrice.subtract(entryPrice)
            : entryPrice.subtract(targetPrice);
    }

    /**
     * Calculates the risk-reward ratio.
     * Returns null if stop loss or target is not set.
     */
    public BigDecimal getRiskRewardRatio() {
        BigDecimal risk = getRiskPerUnit();
        BigDecimal reward = getRewardPerUnit();

        if (risk.compareTo(BigDecimal.ZERO) == 0) {
            return null;
        }
        return reward.divide(risk, 2, BigDecimal.ROUND_HALF_UP);
    }

    // Getters
    public Instrument getInstrument() {
        return instrument;
    }

    public LocalDate getSignalDate() {
        return signalDate;
    }

    public Side getSide() {
        return side;
    }

    public BigDecimal getEntryPrice() {
        return entryPrice;
    }

    public BigDecimal getStopLoss() {
        return stopLoss;
    }

    public BigDecimal getTargetPrice() {
        return targetPrice;
    }

    public int getQuantity() {
        return quantity;
    }

    public String getSymbol() {
        return instrument.getSymbol();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TradeSignal that = (TradeSignal) o;
        return quantity == that.quantity &&
            Objects.equals(instrument, that.instrument) &&
            Objects.equals(signalDate, that.signalDate) &&
            side == that.side &&
            Objects.equals(entryPrice, that.entryPrice) &&
            Objects.equals(stopLoss, that.stopLoss) &&
            Objects.equals(targetPrice, that.targetPrice);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instrument, signalDate, side, entryPrice, stopLoss, targetPrice, quantity);
    }

    @Override
    public String toString() {
        return "TradeSignal{" +
            "symbol='" + getSymbol() + '\'' +
            ", date=" + signalDate +
            ", side=" + side +
            ", entry=" + entryPrice +
            ", stop=" + (stopLoss != null ? stopLoss : "N/A") +
            ", target=" + (targetPrice != null ? targetPrice : "N/A") +
            ", qty=" + quantity +
            '}';
    }
}
